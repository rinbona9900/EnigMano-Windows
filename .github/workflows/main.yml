name: "⚡ EnigMano GCRD Windows — Lock & Auto-Logon Final Magic"

on:
  workflow_dispatch:
    inputs:
      INSTANCE:
        description: "Instance number"
        required: true
        default: "1"
      NEW_USERNAME:
        description: "New local admin to create and set for AutoAdminLogon"
        required: true
        default: "Shahzaib"
      SETUP_CMD_OR_CODE:
        description: "Paste full 'Set up via SSH' command OR just the OAuth code starting with 4/"
        required: true
        default: ""
      DISPLAY_WIDTH:
        description: "Headless display width"
        required: true
        default: "1920"
      DISPLAY_HEIGHT:
        description: "Headless display height"
        required: true
        default: "1080"
      TTL_MINUTES:
        description: "Keep-alive duration for this session (minutes)"
        required: true
        default: "120"

permissions:
  contents: read

concurrency:
  group: enigmano-gcrd
  cancel-in-progress: true

jobs:
  setup:
    runs-on: windows-latest
    timeout-minutes: 340
    env:
      INSTANCE:       ${{ inputs.INSTANCE }}
      RAW_SETUP:      ${{ inputs.SETUP_CMD_OR_CODE }}
      NEW_USERNAME:   ${{ inputs.NEW_USERNAME }}
      RAW_TTL:        ${{ inputs.TTL_MINUTES }}
      DISP_W:         ${{ inputs.DISPLAY_WIDTH }}
      DISP_H:         ${{ inputs.DISPLAY_HEIGHT }}
      DEFAULT_PASS:   "EnigMan0"      # fixed password for all local users
      FIXED_GCRD_PIN: "36446266"      # fixed CRD PIN
      REDIRECT_URL:   "https://remotedesktop.google.com/_/oauthredirect"
      MSI_URL:        "https://dl.google.com/edgedl/chrome-remote-desktop/chromeremotedesktophost.msi"

    steps:
      - name: "Create admin → unify passwords → CRD install/register → warm desktop → lock & verify"
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $ProgressPreference = "SilentlyContinue"

          # ---------------- Inputs ----------------
          $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()
          ).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
          if (-not $isAdmin) { throw "This workflow requires administrative privileges. Current token is not elevated." }

          $instance    = $env:INSTANCE.Trim()
          $TargetUser  = $env:NEW_USERNAME.Trim()
          $setupInput  = $env:RAW_SETUP.Trim()
          $DefaultPass = $env:DEFAULT_PASS
          $CRD_PIN     = $env:FIXED_GCRD_PIN
          $W           = [int]$env:DISP_W
          $H           = [int]$env:DISP_H

          $ttlStr = $env:RAW_TTL.Trim()
          $tmp = 0; if (-not [int]::TryParse($ttlStr, [ref]$tmp)) { $ttlStr = "120" }
          $ttl = [int]$ttlStr; if ($ttl -lt 10) { $ttl = 10 }

          Write-Output "::add-mask::$DefaultPass"
          Write-Output "::add-mask::$CRD_PIN"

          $CRD_NAME = "EnigMano-$instance-$($env:GITHUB_RUN_NUMBER)"
          "TTL_MIN=$ttl"       | Out-File -FilePath $env:GITHUB_ENV -Append
          "CRD_NAME=$CRD_NAME" | Out-File -FilePath $env:GITHUB_ENV -Append

          function Pause([int]$s=3){ Start-Sleep -Seconds $s }

          # helpers
          function Get-FutureSchedule([int]$MinutesAhead=12) {
            $t = (Get-Date).AddMinutes($MinutesAhead)
            [pscustomobject]@{ SD = $t.ToString('MM/dd/yyyy'); ST = $t.ToString('HH:mm') }
          }
          function Sch-Delete([string]$Name){
            Start-Process -FilePath schtasks.exe -ArgumentList @('/delete','/tn',$Name,'/f') -Wait -NoNewWindow -ErrorAction SilentlyContinue | Out-Null
          }
          function Sch-Create([string]$Name,[string]$Cmd,[string]$RunAs,[string]$Pass,[int]$MinutesAhead=12){
            $sched = Get-FutureSchedule -MinutesAhead $MinutesAhead
            Start-Process -FilePath schtasks.exe -ArgumentList @(
              '/create','/tn',$Name,'/tr',"`"$Cmd`"","/sc",'ONCE','/sd',$sched.SD,'/st',$sched.ST,
              '/RL','HIGHEST','/RU',$RunAs,'/RP',$Pass,'/F'
            ) -Wait -NoNewWindow | Out-Null
          }
          function Sch-Run([string]$Name){
            Start-Process -FilePath schtasks.exe -ArgumentList @('/run','/tn',$Name) -Wait -NoNewWindow | Out-Null
          }

          Import-Module Microsoft.PowerShell.LocalAccounts -ErrorAction SilentlyContinue
          Pause 2

          # ---------------- (1) Create/ensure the new local admin ----------------
          if (-not (Get-LocalUser -Name $TargetUser -ErrorAction SilentlyContinue)) {
            & net user $TargetUser "$DefaultPass" /add
          } else {
            & net user $TargetUser "$DefaultPass"
          }
          Pause 4
          & net localgroup Administrators $TargetUser /add | Out-Null
          Pause 3
          try { & net localgroup "Remote Desktop Users" $TargetUser /add | Out-Null } catch {}
          Pause 2
          if (Get-Command Set-LocalUser -ErrorAction SilentlyContinue) {
            try { Set-LocalUser -Name $TargetUser -PasswordNeverExpires $true } catch {}
          }
          Pause 2

          # ---------------- (2) Set SAME PASSWORD for ALL local users (best-effort) ----------------
          Get-LocalUser | ForEach-Object {
            $n = $_.Name
            try { & net user $n "$DefaultPass" | Out-Null } catch {}
          }
          Pause 3

          # ---------------- (3) AutoAdminLogon (applies next boot; we still warm-in now) ----------------
          $wl = "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
          & reg add "$wl" /v AutoAdminLogon    /t REG_SZ    /d "1"            /f | Out-Null
          & reg add "$wl" /v ForceAutoLogon    /t REG_DWORD /d 1              /f | Out-Null
          & reg add "$wl" /v DefaultUserName   /t REG_SZ    /d "$TargetUser"  /f | Out-Null
          & reg add "$wl" /v DefaultDomainName /t REG_SZ    /d "$env:COMPUTERNAME" /f | Out-Null
          & reg add "$wl" /v DefaultPassword   /t REG_SZ    /d "$DefaultPass" /f | Out-Null
          Pause 3

          # cosmetic only
          reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v DontDisplayLastUsername /t REG_DWORD /d 1 /f | Out-Null
          reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v HideFastUserSwitching  /t REG_DWORD /d 1 /f | Out-Null
          Pause 2

          # ---------------- (4) Local RDP (informational; CRD is what you'll use) ----------------
          Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" -Value 0
          Enable-NetFirewallRule -DisplayGroup "Remote Desktop" | Out-Null
          Set-Service -Name TermService -StartupType Automatic
          try { Start-Service TermService } catch {}
          Pause 3

          # ---------------- (5) Install Chrome Remote Desktop Host ----------------
          $WorkDir = Join-Path $env:ProgramData "EnigMano"
          New-Item -Path $WorkDir -ItemType Directory -Force | Out-Null
          Pause 2

          $msi = Join-Path $WorkDir "chromeremotedesktophost.msi"
          Invoke-WebRequest -Uri $env:MSI_URL -OutFile $msi
          Pause 3
          Start-Process -FilePath "msiexec.exe" -ArgumentList @("/i",$msi,"/qn","/norestart") -Wait -NoNewWindow
          Pause 5

          $pf86 = [Environment]::GetFolderPath('ProgramFilesX86')
          $CRD_EXE = $null
          $cand = Get-ChildItem -Path (Join-Path $pf86 'Google\Chrome Remote Desktop') -Recurse -Filter "remoting_start_host.exe" -ErrorAction SilentlyContinue | Sort-Object FullName -Descending | Select-Object -First 1
          if ($cand) { $CRD_EXE = $cand.FullName } else { $CRD_EXE = Join-Path $pf86 'Google\Chrome Remote Desktop\CurrentVersion\remoting_start_host.exe' }
          if (-not (Test-Path $CRD_EXE)) { throw "remoting_start_host.exe not found at: $CRD_EXE" }
          Pause 2

          $svc = Get-Service -Name chromoting -ErrorAction SilentlyContinue
          if ($svc) { sc.exe config chromoting start= auto | Out-Null }
          Pause 3

          # parse OAuth code
          $code = $null
          if     ($setupInput -match 'code="?([^"\s]+)"?') { $code = $Matches[1] }
          elseif ($setupInput -match '(4\/[A-Za-z0-9._~-]+)') { $code = $Matches[1] }
          if (-not $code) { throw "No OAuth code detected. Paste full command w/ --code=... or the code starting with '4/'." }
          Write-Output "::add-mask::$code"
          Pause 1

          # ---------------- (6) Register CRD host AS the new user (fixed PIN) ----------------
          $CRD_ARGS = "--code=""$code"" --redirect-url=""$($env:REDIRECT_URL)"" --name=""$CRD_NAME"" --pin=""$CRD_PIN"""
          $regCmd   = Join-Path $WorkDir "crd_register.cmd"
          Set-Content -Path $regCmd -Value @(
            '@echo off'
            '"' + $CRD_EXE + '" ' + $CRD_ARGS
            'exit /b %errorlevel%'
          ) -Encoding Ascii
          Pause 2

          $runAs   = "$($env:COMPUTERNAME)\$TargetUser"
          $regTask = "CRD-Register-$CRD_NAME"
          Sch-Delete $regTask
          Sch-Create -Name $regTask -Cmd $regCmd -RunAs $runAs -Pass $DefaultPass -MinutesAhead 12
          Pause 4
          Sch-Run $regTask
          Pause 12

          # ---------------- (7) Logon new user headlessly (desktop + keepalive) ----------------
          $warmCmd = Join-Path $WorkDir "warmin.cmd"
          Set-Content -Path $warmCmd -Value @(
            '@echo off'
            'whoami > %TEMP%\enigmano_whoami.txt'
            'start "" "%SystemRoot%\explorer.exe"'
            'exit /b 0'
          ) -Encoding Ascii
          Pause 2

          $warmTask = "CRD-WarmIn-$CRD_NAME"
          Sch-Delete $warmTask
          Sch-Create -Name $warmTask -Cmd $warmCmd -RunAs $runAs -Pass $DefaultPass -MinutesAhead 13
          Pause 4
          Sch-Run $warmTask
          Pause 10

          $keepCmd = Join-Path $WorkDir "keepalive.cmd"
          Set-Content -Path $keepCmd -Value @(
            '@echo off'
            ':loop'
            'ping -n 31 127.0.0.1 >nul'
            'goto loop'
          ) -Encoding Ascii
          Pause 2

          $keepTask = "CRD-KeepAlive-$CRD_NAME"
          Sch-Delete $keepTask
          Sch-Create -Name $keepTask -Cmd $keepCmd -RunAs $runAs -Pass $DefaultPass -MinutesAhead 14
          Pause 4
          Sch-Run $keepTask
          Pause 8

          # Wait for HKU\<SID> to mount = profile loaded
          $sid = (Get-LocalUser -Name $TargetUser).Sid.Value
          $mounted = $false
          foreach ($i in 1..60) { if (Test-Path "Registry::HKEY_USERS\$sid") { $mounted = $true; break }; Start-Sleep -Seconds 1 }
          Pause 2

          # ---------------- (8) DPI 100% (per-user) & default headless resolution ----------------
          if ($mounted) {
            reg add "HKU\$sid\Control Panel\Desktop" /v LogPixels /t REG_DWORD /d 96 /f | Out-Null
            reg add "HKU\$sid\Control Panel\Desktop" /v Win8DpiScaling /t REG_DWORD /d 0 /f | Out-Null
          }
          Pause 2

          function Set-HeadlessRes {
            param([int]$W = 1920, [int]$H = 1080)
            $gfxRoot = "HKLM:\SYSTEM\CurrentControlSet\Control\GraphicsDrivers\Configuration"
            if (Test-Path $gfxRoot) {
              Get-ChildItem $gfxRoot -ErrorAction SilentlyContinue | ForEach-Object {
                $k1 = Join-Path $_.PSPath "00"
                $k2 = Join-Path $k1 "00"
                try {
                  New-Item -Path $k1 -Force | Out-Null
                  New-Item -Path $k2 -Force | Out-Null
                  New-ItemProperty -Path $k1 -Name "PrimSurfSize.cx" -Value $W -PropertyType DWord -Force | Out-Null
                  New-ItemProperty -Path $k1 -Name "PrimSurfSize.cy" -Value $H -PropertyType DWord -Force | Out-Null
                  New-ItemProperty -Path $k1 -Name "Stride"         -Value ([int]($W * 4)) -PropertyType DWord -Force | Out-Null
                  New-ItemProperty -Path $k2 -Name "ActiveSize.cx"  -Value $W -PropertyType DWord -Force | Out-Null
                  New-ItemProperty -Path $k2 -Name "ActiveSize.cy"  -Value $H -PropertyType DWord -Force | Out-Null
                } catch {}
              }
            }
          }
          Set-HeadlessRes -W $W -H $H
          Pause 3

          # Soft-apply display without reboot
          try {
            Import-Module PnpDevice -ErrorAction SilentlyContinue
            $disp = Get-PnpDevice -Class Display -Status OK -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($disp) {
              Disable-PnpDevice -InstanceId $disp.InstanceId -Confirm:$false -ErrorAction SilentlyContinue | Out-Null
              Start-Sleep -Seconds 3
              Enable-PnpDevice  -InstanceId $disp.InstanceId -Confirm:$false -ErrorAction SilentlyContinue | Out-Null
            }
          } catch {}
          Pause 3

          # ---------------- (9) LOCK console (runneradmin stays alive) ----------------
          try {
            Start-Process -FilePath "$env:SystemRoot\System32\rundll32.exe" -ArgumentList 'user32.dll,LockWorkStation' -NoNewWindow -Wait
          } catch {}
          Pause 6

          # After lock: re-assert new user session (run warm/keep again) and verify
          Sch-Run $warmTask
          Pause 8
          Sch-Run $keepTask
          Pause 5

          # Verify: processes by TargetUser; if missing, retry a few times
          $maxRetries = 4
          for ($try=1; $try -le $maxRetries; $try++) {
            $procs = @()
            try { $procs = Get-Process -IncludeUserName | Where-Object { $_.UserName -like "*\$TargetUser" } } catch {}
            $hiveLoaded = Test-Path "Registry::HKEY_USERS\$sid"
            if ($procs.Count -gt 0 -and $hiveLoaded) { break }
            # re-run warm/keep and wait a bit more
            Sch-Run $warmTask
            Pause 10
            Sch-Run $keepTask
            Pause 10
          }

          # Ensure CRD service is running
          function TryStart([string]$name) {
            $ErrorActionPreference = "Continue"
            $s = Get-Service -Name $name -ErrorAction SilentlyContinue
            if ($s) {
              sc.exe config $name start= auto | Out-Null
              foreach ($i in 1..8) {
                try { Start-Service $name -ErrorAction Stop } catch { Start-Sleep -Seconds 5; continue }
                $s = Get-Service -Name $name -ErrorAction SilentlyContinue
                if ($s.Status -eq 'Running') { return $true }
                Start-Sleep -Seconds 3
              }
            }
            return $false
          }
          $null = TryStart "chromoting"
          Pause 2

          # ---------------- Diagnostics ----------------
          Write-Host "=== CRD Service Status ==="
          Get-Service -Name chromoting -ErrorAction SilentlyContinue | Format-Table -Auto

          Write-Host "`n=== Local Users (password unified; all untouched) ==="
          Get-LocalUser | Select-Object Name,Enabled | Format-Table -Auto

          Write-Host "`n=== AutoAdminLogon Target ==="
          Write-Host "Configured for next boot: $TargetUser"

          Write-Host "`n=== Session Snapshot (runneradmin locked; background alive) ==="
          try { query user } catch {}

          Write-Host "`n=== Processes owned by $TargetUser (proof of active session) ==="
          try { Get-Process -IncludeUserName | Where-Object { $_.UserName -like "*\$TargetUser" } | Select-Object Name,Id,SessionId,UserName | Format-Table -Auto } catch {}

          # Do not fail on harmless native exit codes
          $global:LASTEXITCODE = 0

      - name: "Connect instructions + keep alive"
        if: ${{ always() }}
        shell: pwsh
        run: |
          Write-Host "====================================================="
          Write-Host " ✅ Chrome Remote Desktop is registered."
          Write-Host "    Host: $env:CRD_NAME"
          Write-Host "    Open: https://remotedesktop.google.com/access (same Google account used for the code)"
          Write-Host "-----------------------------------------------------"
          Write-Host "Passwords unified to 'EnigMan0' for all local users (best-effort)."
          Write-Host "Console (runneradmin) is locked and stays alive in background."
          Write-Host "New user session is warm & active (desktop + keepalive)."
          Write-Host "Headless display: $env:DISP_W x $env:DISP_H; DPI 100%."
          Write-Host "====================================================="
          Start-Sleep -Seconds (60 * [int]$env:TTL_MIN)
