name: "⚡ EnigMano GCRD Windows — Ultra+ (Interactive Autologon & 1080p)"

on:
  workflow_dispatch:
    inputs:
      INSTANCE:
        description: "Instance number"
        required: true
        default: "1"
      SETUP_CMD_OR_CODE:
        description: "Paste the full 'Set up via SSH' command OR just the OAuth code starting with 4/"
        required: true
        default: ""
      NEW_USERNAME:
        description: "Create this local admin (leave blank to use runneradmin)"
        required: false
        default: ""
      GCRD_REDIRECT_URL:
        description: "Redirect URL from Google (leave default)"
        required: false
        default: "https://remotedesktop.google.com/_/oauthredirect"
      TTL_MINUTES:
        description: "Keep-alive duration for this session"
        required: false
        default: "120"

permissions:
  contents: read

concurrency:
  group: enigmano-gcrd
  cancel-in-progress: true

jobs:
  setup:
    runs-on: windows-latest
    timeout-minutes: 340
    env:
      INSTANCE:           ${{ inputs.INSTANCE }}
      RAW_SETUP:          ${{ inputs.SETUP_CMD_OR_CODE }}
      RAW_NEW_USERNAME:   ${{ inputs.NEW_USERNAME }}
      RAW_REDIRECT_URL:   ${{ inputs.GCRD_REDIRECT_URL }}
      RAW_TTL:            ${{ inputs.TTL_MINUTES }}

      # === Single source of truth (fixed as requested) ===
      DEFAULT_PASS:   "EnigMan0"   # Local account password (fixed)
      FIXED_GCRD_PIN: "36446266"   # CRD PIN (fixed numeric as required)

      MSI_URL: https://dl.google.com/edgedl/chrome-remote-desktop/chromeremotedesktophost.msi
      # Sysinternals + NirCmd (official links)
      SYSINT_URL: https://download.sysinternals.com/files/SysinternalsSuite.zip
      NIRCMD_URL: https://www.nirsoft.net/utils/nircmd-x64.zip

    steps:
      - name: "Setup Environment"
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # ---------- Normalize Inputs ----------
          $instance     = ($env:INSTANCE         | ForEach-Object { $_.Trim() })
          $setupInput   = ($env:RAW_SETUP        | ForEach-Object { $_.Trim() })
          $redirectUrl  = ($env:RAW_REDIRECT_URL | ForEach-Object { $_.Trim() })
          $newUser      = ($env:RAW_NEW_USERNAME | ForEach-Object { $_.Trim() })
          $ttlStr       = ($env:RAW_TTL          | ForEach-Object { $_.Trim() })

          $tmp = 0
          if (-not [int]::TryParse($ttlStr, [ref]$tmp)) { $ttlStr = "120" }
          $ttl = [int]$ttlStr
          if ($ttl -lt 10) { $ttl = 10 }

          $DefaultPass = $env:DEFAULT_PASS
          $Pin         = $env:FIXED_GCRD_PIN
          "::add-mask::$DefaultPass" | Out-Host
          "::add-mask::$Pin" | Out-Host

          # ---------- Target user ----------
          $TargetUser = if ([string]::IsNullOrWhiteSpace($newUser)) { "runneradmin" } else { $newUser }

          # ---------- Export shared env ----------
          "TTL_MIN=$ttl" | Out-File -FilePath $env:GITHUB_ENV -Append
          $CRD_NAME = "EnigMano-$instance-$($env:GITHUB_RUN_NUMBER)"
          "CRD_NAME=$CRD_NAME" | Out-File -FilePath $env:GITHUB_ENV -Append

          Start-Sleep -Seconds 2

          # ---------- Ensure/prepare Target Account (admin) ----------
          if ($TargetUser -eq "runneradmin") {
            net user runneradmin "$DefaultPass"
            try { net localgroup Administrators runneradmin /add | Out-Null } catch {}
          } else {
            if (-not (Get-LocalUser -Name $TargetUser -ErrorAction SilentlyContinue)) {
              net user $TargetUser "$DefaultPass" /add
            } else {
              net user $TargetUser "$DefaultPass"
            }
            net localgroup Administrators $TargetUser /add
          }
          if (Get-Command Set-LocalUser -ErrorAction SilentlyContinue) {
            try { Set-LocalUser -Name $TargetUser -PasswordNeverExpires $true } catch {}
          }
          Start-Sleep -Seconds 2

          # ---------- Persist AutoAdminLogon (for future boots), but we'll also create a session NOW ----------
          $wl = "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
          & reg add "$wl" /v AutoAdminLogon    /t REG_SZ    /d "1"            /f | Out-Null
          & reg add "$wl" /v ForceAutoLogon    /t REG_DWORD /d 1              /f | Out-Null
          & reg add "$wl" /v DefaultUserName   /t REG_SZ    /d "$TargetUser"  /f | Out-Null
          & reg add "$wl" /v DefaultDomainName /t REG_SZ    /d "$env:COMPUTERNAME" /f | Out-Null
          & reg add "$wl" /v DefaultPassword   /t REG_SZ    /d "$DefaultPass" /f | Out-Null
          Start-Sleep -Seconds 2

          # ---------- Enable local RDP (informational; CRD is primary) ----------
          try {
            Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" -Value 0
            Enable-NetFirewallRule -DisplayGroup "Remote Desktop" | Out-Null
            Set-Service -Name TermService -StartupType Automatic
            Start-Service TermService
          } catch {}
          Start-Sleep -Seconds 2

          # ---------- Install Chrome Remote Desktop Host ----------
          $msi = Join-Path $env:TEMP "chromeremotedesktophost.msi"
          Invoke-WebRequest -Uri "${{ env.MSI_URL }}" -OutFile $msi
          Start-Process -FilePath "msiexec.exe" -ArgumentList @("/i", $msi, "/qn", "/norestart") -Wait
          Start-Sleep -Seconds 5

          # ---------- Discover CRD host binary (path drift safe) ----------
          $pf86 = [Environment]::GetFolderPath('ProgramFilesX86')
          $pf64 = $env:ProgramFiles
          $candidates = @(
            (Join-Path $pf86 'Google\Chrome Remote Desktop\CurrentVersion\remoting_start_host.exe'),
            (Join-Path $pf64 'Google\Chrome Remote Desktop\CurrentVersion\remoting_start_host.exe')
          )
          $search = Get-ChildItem -Path (Join-Path $pf86 'Google\Chrome Remote Desktop') -Recurse -Filter remoting_start_host.exe -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName
          if ($search) { $candidates += $search }
          $CRD_EXE = $candidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $CRD_EXE) { throw "remoting_start_host.exe not found in expected locations." }

          # ---------- Stable CRD policies ----------
          reg add HKLM\Software\Policies\Google\Chrome /v RemoteAccessHostRequireCurtain /d 1 /t REG_DWORD /f | Out-Null
          reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /d 0 /t REG_DWORD /f | Out-Null
          reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v SecurityLayer /d 1 /t REG_DWORD /f | Out-Null
          reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /d 0 /t REG_DWORD /f | Out-Null

          $svc = Get-Service -Name chromoting -ErrorAction SilentlyContinue
          if ($svc) { sc.exe config chromoting start= auto | Out-Null }
          Start-Sleep -Seconds 2

          # ---------- Parse OAuth code robustly ----------
          $code = $null
          if ($setupInput -match 'code="?([0-9A-Za-z\/\-\._~]+)"?') { $code = $Matches[1] }
          elseif ($setupInput -match '(4\/[0-9A-Za-z\-\._~]+)')     { $code = $Matches[1] }
          if (-not $code) { throw "No OAuth code detected. Paste full command w/ --code=... or the code starting with '4/'." }
          "::add-mask::$code" | Out-Host

          # ---------- Build CRD args ----------
          $args = @(
            "--code=""$code"""
            "--redirect-url=""$redirectUrl"""
            "--name=""$CRD_NAME"""
            "--pin=""$Pin"""
          ) -join " "

          # ---------- Register CRD via Scheduled Task (avoid /st 00:00 bug) ----------
          $task = "CRD-Register-$CRD_NAME"
          $cmd  = Join-Path $env:TEMP "crd_register.cmd"
          "@echo off`r`n""$CRD_EXE"" $args`r`nexit /b %errorlevel%" | Out-File -FilePath $cmd -Encoding ASCII -Force

          $start = (Get-Date).AddMinutes(2).ToString('HH:mm')
          schtasks /create /tn "$task" /tr "$cmd" /sc ONCE /st $start /RL HIGHEST /RU "$env:COMPUTERNAME\$TargetUser" /RP "$DefaultPass" /F | Out-Null
          Start-Sleep -Seconds 2
          schtasks /run /tn "$task" | Out-Null
          Start-Sleep -Seconds 10

          # ---------- DOWNLOAD PsExec + NirCmd (to create live interactive session and set 1080p) ----------
          $ToolsDir = Join-Path $env:TEMP "em-tools"
          New-Item -ItemType Directory -Force -Path $ToolsDir | Out-Null

          $sysZip = Join-Path $ToolsDir "sysinternals.zip"
          Invoke-WebRequest -Uri "${{ env.SYSINT_URL }}" -OutFile $sysZip
          Expand-Archive -Path $sysZip -DestinationPath $ToolsDir -Force
          $PsExec = Get-ChildItem -Path $ToolsDir -Recurse -Filter "PsExec.exe" | Select-Object -First 1
          if (-not $PsExec) { throw "PsExec.exe not found after download." }

          $nirZip = Join-Path $ToolsDir "nircmd.zip"
          Invoke-WebRequest -Uri "${{ env.NIRCMD_URL }}" -OutFile $nirZip
          Expand-Archive -Path $nirZip -DestinationPath $ToolsDir -Force
          $NirCmd = Get-ChildItem -Path $ToolsDir -Recurse -Filter "nircmdc.exe" | Select-Object -First 1
          if (-not $NirCmd) { throw "nircmdc.exe not found after download." }

          Start-Sleep -Seconds 2

          # ---------- CREATE INTERACTIVE DESKTOP SESSION for TargetUser NOW (no reboot) ----------
          # Console session is typically 1 on GH runners; use -i 1 to attach and start explorer.exe
          & "$($PsExec.FullName)" -accepteula -i 1 -u "$env:COMPUTERNAME\$TargetUser" -p "$DefaultPass" cmd /c "whoami > %TEMP%\whoami.txt & start explorer.exe"
          Start-Sleep -Seconds 6

          # ---------- FORCE 1920x1080 @ 32bpp + 100% DPI inside that user session ----------
          & "$($PsExec.FullName)" -accepteula -i 1 -u "$env:COMPUTERNAME\$TargetUser" -p "$DefaultPass" `"$($NirCmd.FullName)`" setdisplay 1920 1080 32
          Start-Sleep -Seconds 3
          # Also ensure 100% DPI (96 DPI)
          & "$($PsExec.FullName)" -accepteula -i 1 -u "$env:COMPUTERNAME\$TargetUser" -p "$DefaultPass" `"$($NirCmd.FullName)`" setdpiscale 100
          Start-Sleep -Seconds 3

          # ---------- Extra: ensure registry headless values (best-effort, harmless if already set) ----------
          function Set-HeadlessRes {
            param([int]$W = 1920, [int]$H = 1080)
            $gfxRoot = "HKLM:\SYSTEM\CurrentControlSet\Control\GraphicsDrivers\Configuration"
            if (Test-Path $gfxRoot) {
              Get-ChildItem $gfxRoot -ErrorAction SilentlyContinue | ForEach-Object {
                $k1 = Join-Path $_.PSPath "00"
                $k2 = Join-Path $k1 "00"
                try {
                  New-Item -Path $k1 -Force | Out-Null
                  New-Item -Path $k2 -Force | Out-Null
                  New-ItemProperty -Path $k1 -Name "PrimSurfSize.cx" -Value $W -PropertyType DWord -Force | Out-Null
                  New-ItemProperty -Path $k1 -Name "PrimSurfSize.cy" -Value $H -PropertyType DWord -Force | Out-Null
                  New-ItemProperty -Path $k1 -Name "Stride"         -Value ($W * 4) -PropertyType DWord -Force | Out-Null
                  New-ItemProperty -Path $k2 -Name "ActiveSize.cx"  -Value $W -PropertyType DWord -Force | Out-Null
                  New-ItemProperty -Path $k2 -Name "ActiveSize.cy"  -Value $H -PropertyType DWord -Force | Out-Null
                } catch {}
              }
            }
          }
          Set-HeadlessRes 1920 1080
          Start-Sleep -Seconds 2

          # ---------- Start CRD service with retries ----------
          function TryStart([string]$name) {
            $ErrorActionPreference = "Continue"
            $s = Get-Service -Name $name -ErrorAction SilentlyContinue
            if ($s) {
              sc.exe config $name start= auto | Out-Null
              for ($i=0; $i -lt 8; $i++) {
                try { Start-Service $name -ErrorAction Stop } catch { Start-Sleep -Seconds 5; continue }
                $s = Get-Service -Name $name -ErrorAction SilentlyContinue
                if ($s.Status -eq 'Running') { return $true }
                Start-Sleep -Seconds 3
              }
            }
            return $false
          }
          $null = TryStart "chromoting"
          Start-Sleep -Seconds 2

          # ---------- (Optional) Enforce only TargetUser enabled after registration ----------
          try {
            Get-LocalUser | ForEach-Object {
              $name = $_.Name
              if ($name -ne $TargetUser) {
                try { Disable-LocalUser -Name $name -ErrorAction SilentlyContinue } catch {}
              } else {
                if (Get-Command Set-LocalUser -ErrorAction SilentlyContinue) {
                  try { Set-LocalUser -Name $name -PasswordNeverExpires $true } catch {}
                }
              }
            }
          } catch {}
          Start-Sleep -Seconds 2

          # ---------- Diagnostics ----------
          Write-Host "=== WhoAmI (from TargetUser session) ==="
          Get-Content "$env:TEMP\whoami.txt" -ErrorAction SilentlyContinue | Out-String | Write-Host

          Write-Host "`n=== CRD Service Status ==="
          Get-Service -Name chromoting -ErrorAction SilentlyContinue | Format-Table -Auto

          Write-Host "`n=== Accounts (post-enforcement) ==="
          Get-LocalUser | Select-Object Name,Enabled | Format-Table -Auto

          Write-Host "`n=== AutoAdminLogon Target ==="
          Write-Host "Will auto-logon as: $TargetUser"

          Write-Host "`n=== Display Devices ==="
          try { Get-PnpDevice -Class Display -ErrorAction SilentlyContinue | Format-Table -Auto } catch {}

      - name: "Connect instructions + keep alive"
        if: ${{ always() }}
        shell: pwsh
        run: |
          Write-Host "====================================================="
          Write-Host " ✅ Chrome Remote Desktop registration attempted."
          Write-Host "    Name: $env:CRD_NAME"
          Write-Host "    Sign into the SAME Google account used to create the code,"
          Write-Host "    then open: https://remotedesktop.google.com/access"
          Write-Host "    Your host should appear as: $env:CRD_NAME"
          Write-Host "-----------------------------------------------------"
          Write-Host "A live desktop session for the target user has been created (no reboot needed)."
          Write-Host "Resolution set to 1920x1080 and DPI to 100% inside that session."
          Write-Host "Note: RDP is enabled locally for completeness, but GitHub-hosted"
          Write-Host "runners do not accept inbound RDP from the internet."
          Write-Host "Use Chrome Remote Desktop (PIN: ******) for access."
          Write-Host "====================================================="
          Start-Sleep -Seconds (60 * [int]$env:TTL_MIN)
