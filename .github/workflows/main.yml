name: "EnigMano GCRD Windows â€” Magical Ultra Clean"

on:
  workflow_dispatch:
    inputs:
      INSTANCE:
        description: "Instance number"
        required: true
        default: "1"
      SETUP_CMD_OR_CODE:
        description: "Paste the full 'Set up via SSH' command OR just the OAuth code starting with 4/"
        required: true
        default: ""
      NEW_USERNAME:
        description: "Create this local admin (leave blank to use runneradmin)"
        required: false
        default: "Shahzaib"
      GCRD_REDIRECT_URL:
        description: "Redirect URL from Google (leave default)"
        required: false
        default: "https://remotedesktop.google.com/_/oauthredirect"
      TTL_MINUTES:
        description: "Keep-alive duration for this session (minutes)"
        required: false
        default: "120"

permissions:
  contents: read

concurrency:
  group: enigmano-gcrd
  cancel-in-progress: true

jobs:
  setup:
    runs-on: windows-latest
    timeout-minutes: 340
    env:
      INSTANCE:           ${{ inputs.INSTANCE }}
      RAW_SETUP:          ${{ inputs.SETUP_CMD_OR_CODE }}
      RAW_NEW_USERNAME:   ${{ inputs.NEW_USERNAME }}
      RAW_REDIRECT_URL:   ${{ inputs.GCRD_REDIRECT_URL }}
      RAW_TTL:            ${{ inputs.TTL_MINUTES }}

      # Single source of truth (requested)
      DEFAULT_PASS:   "EnigMan0"   # local user password (fixed)
      FIXED_GCRD_PIN: "36446266"   # CRD PIN (fixed numeric)

      MSI_URL: https://dl.google.com/edgedl/chrome-remote-desktop/chromeremotedesktophost.msi

    steps:
      - name: Prep variables and ensure admin user
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $instance    = ($env:INSTANCE         | % { $_.Trim() })
          $setupInput  = ($env:RAW_SETUP        | % { $_.Trim() })
          $redirectUrl = ($env:RAW_REDIRECT_URL | % { $_.Trim() })
          $newUser     = ($env:RAW_NEW_USERNAME | % { $_.Trim() })
          $ttlStr      = ($env:RAW_TTL          | % { $_.Trim() })

          if (-not [int]::TryParse($ttlStr, [ref]0)) { $ttlStr = "120" }
          $ttl = [int]$ttlStr; if ($ttl -lt 10) { $ttl = 10 }

          $DefaultPass = $env:DEFAULT_PASS
          $Pin         = $env:FIXED_GCRD_PIN
          Write-Output "::add-mask::$DefaultPass"
          Write-Output "::add-mask::$Pin"

          $TargetUser = if ([string]::IsNullOrWhiteSpace($newUser)) { "runneradmin" } else { $newUser }

          "TTL_MIN=$ttl" | Out-File -FilePath $env:GITHUB_ENV -Append
          $CRD_NAME = "EnigMano-$instance-$($env:GITHUB_RUN_NUMBER)"
          "CRD_NAME=$CRD_NAME" | Out-File -FilePath $env:GITHUB_ENV -Append

          # Ensure the admin user and add to Administrators
          if ($TargetUser -eq "runneradmin") {
            net user runneradmin "$DefaultPass"
            try { net localgroup Administrators runneradmin /add | Out-Null } catch {}
          } else {
            if (-not (Get-LocalUser -Name $TargetUser -ErrorAction SilentlyContinue)) {
              net user $TargetUser "$DefaultPass" /add
            } else {
              net user $TargetUser "$DefaultPass"
            }
            net localgroup Administrators $TargetUser /add
          }
          try { Set-LocalUser -Name $TargetUser -PasswordNeverExpires $true } catch {}

          Start-Sleep -Seconds 2

          # AutoAdminLogon for next boots
          $wl = "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
          reg add "$wl" /v AutoAdminLogon    /t REG_SZ    /d "1"            /f | Out-Null
          reg add "$wl" /v ForceAutoLogon    /t REG_DWORD /d 1              /f | Out-Null
          reg add "$wl" /v DefaultUserName   /t REG_SZ    /d "$TargetUser"  /f | Out-Null
          reg add "$wl" /v DefaultDomainName /t REG_SZ    /d "$env:COMPUTERNAME" /f | Out-Null
          reg add "$wl" /v DefaultPassword   /t REG_SZ    /d "$DefaultPass" /f | Out-Null

          # Keep awake
          powercfg -x -monitor-timeout-ac 0
          powercfg -x -standby-timeout-ac 0
          powercfg -x -hibernate-timeout-ac 0

      - name: Install Chrome Remote Desktop host
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $msi = Join-Path $env:TEMP "chromeremotedesktophost.msi"
          Invoke-WebRequest -Uri "${{ env.MSI_URL }}" -OutFile $msi
          Start-Process msiexec.exe -ArgumentList @("/i",$msi,"/qn","/norestart") -Wait
          Start-Sleep -Seconds 4

      - name: Register CRD under target user
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $DefaultPass = $env:DEFAULT_PASS
          $Pin         = $env:FIXED_GCRD_PIN
          $TargetUser  = if ([string]::IsNullOrWhiteSpace($env:RAW_NEW_USERNAME)) { "runneradmin" } else { $env:RAW_NEW_USERNAME }
          $CRD_NAME    = $env:CRD_NAME
          $redirectUrl = $env:RAW_REDIRECT_URL
          $setupInput  = $env:RAW_SETUP

          # Find CRD host binary (handle path drift)
          $pf86 = [Environment]::GetFolderPath('ProgramFilesX86'); $pf64 = $env:ProgramFiles
          $cands = @(
            (Join-Path $pf86 'Google\Chrome Remote Desktop\CurrentVersion\remoting_start_host.exe'),
            (Join-Path $pf64 'Google\Chrome Remote Desktop\CurrentVersion\remoting_start_host.exe')
          )
          $probe = Get-ChildItem -Path (Join-Path $pf86 'Google\Chrome Remote Desktop') -Recurse -Filter remoting_start_host.exe -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName
          if ($probe) { $cands += $probe }
          $CRD_EXE = $cands | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $CRD_EXE) { throw "remoting_start_host.exe not found." }

          # Stable CRD policies
          reg add HKLM\Software\Policies\Google\Chrome /v RemoteAccessHostRequireCurtain /d 1 /t REG_DWORD /f | Out-Null
          reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /d 0 /t REG_DWORD /f | Out-Null
          reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v SecurityLayer /d 1 /t REG_DWORD /f | Out-Null
          reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v UserAuthentication /d 0 /t REG_DWORD /f | Out-Null

          # Parse OAuth code robustly
          $code = $null
          if ($setupInput -match 'code="?([0-9A-Za-z\/\-\._~]+)"?') { $code = $Matches[1] }
          elseif ($setupInput -match '(4\/[0-9A-Za-z\-\._~]+)')     { $code = $Matches[1] }
          if (-not $code) { throw "No OAuth code detected. Paste full command with --code=... or the code starting with '4/'." }
          Write-Output "::add-mask::$code"

          $args = @("--code=""$code""","--redirect-url=""$redirectUrl""","--name=""$CRD_NAME""","--pin=""$Pin""") -join " "

          # Preferred: register in the target user's context directly
          $sec  = ConvertTo-SecureString $DefaultPass -AsPlainText -Force
          $cred = New-Object System.Management.Automation.PSCredential("$env:COMPUTERNAME\$TargetUser",$sec)
          $crdOk = $false
          try {
            Start-Process -FilePath $CRD_EXE -ArgumentList $args -Credential $cred -LoadUserProfile -WindowStyle Hidden -Wait
            $crdOk = $true
          } catch {
            Write-Host "Direct CRD register failed ($($_.Exception.Message)). Falling back to scheduled task."
          }

          if (-not $crdOk) {
            $task = "CRD-Register-$CRD_NAME"
            $cmd  = Join-Path $env:TEMP "crd_register.cmd"
            "@echo off`r`n""$CRD_EXE"" $args`r`nexit /b %errorlevel%" | Out-File -FilePath $cmd -Encoding ASCII -Force
            $st = (Get-Date).AddMinutes(2).ToString('HH:mm')
            schtasks /create /tn "$task" /tr "$cmd" /sc ONCE /st $st /RL HIGHEST /RU "$env:COMPUTERNAME\$TargetUser" /RP "$DefaultPass" /F | Out-Null
            Start-Sleep -Seconds 2
            schtasks /run /tn "$task" | Out-Null
            Start-Sleep -Seconds 8
          }

          # Start CRD service with retry
          function TryStart([string]$n){
            $s = Get-Service -Name $n -EA SilentlyContinue
            if ($s) {
              sc.exe config $n start= auto | Out-Null
              for ($i=0;$i -lt 8;$i++){
                try { Start-Service $n -EA Stop } catch { Start-Sleep -Seconds 3; continue }
                $s = Get-Service -Name $n -EA SilentlyContinue
                if ($s.Status -eq 'Running'){ return $true }
                Start-Sleep -Seconds 2
              }
            }
            return $false
          }
          if (-not (TryStart "chromoting")) {
            $svc2 = Get-Service -DisplayName "Chrome Remote Desktop Service" -EA SilentlyContinue
            if ($svc2) { [void](TryStart $svc2.Name) }
          }

      - name: Force logged-on desktop session for target user
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $TargetUser  = if ([string]::IsNullOrWhiteSpace($env:RAW_NEW_USERNAME)) { "runneradmin" } else { $env:RAW_NEW_USERNAME }
          $DefaultPass = $env:DEFAULT_PASS

          $sec  = ConvertTo-SecureString $DefaultPass -AsPlainText -Force
          $cred = New-Object System.Management.Automation.PSCredential("$env:COMPUTERNAME\$TargetUser",$sec)

          # Launch user shell to create a real session now
          try {
            Start-Process -FilePath "$env:WINDIR\System32\userinit.exe" -ArgumentList "$env:WINDIR\explorer.exe" -Credential $cred -LoadUserProfile -WindowStyle Hidden
            Start-Sleep -Seconds 3
          } catch {
            Write-Host "Userinit launch warning: $($_.Exception.Message)"
          }

          # Show any explorer owners
          try {
            $procs = Get-WmiObject Win32_Process -Filter "Name='explorer.exe'"
            foreach ($p in $procs){ $null=$p.GetOwner([ref]$u,[ref]$d); if ($u) { Write-Host "Explorer owned by: $d\$u" } }
          } catch {}

      - name: Apply selected 1920x1080 in user session (Win32 API) with fallback
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $TargetUser  = if ([string]::IsNullOrWhiteSpace($env:RAW_NEW_USERNAME)) { "runneradmin" } else { $env:RAW_NEW_USERNAME }
          $DefaultPass = $env:DEFAULT_PASS

          $sec  = ConvertTo-SecureString $DefaultPass -AsPlainText -Force
          $cred = New-Object System.Management.Automation.PSCredential("$env:COMPUTERNAME\$TargetUser",$sec)

          # Build a tiny PS1 that compiles and calls ChangeDisplaySettings
          $setResPs1 = Join-Path $env:TEMP "apply_res.ps1"
          $lines = @()
          $lines += "Add-Type -TypeDefinition @'"
          $lines += "using System;"
          $lines += "using System.Runtime.InteropServices;"
          $lines += "public class SetRes {"
          $lines += "  [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Ansi)]"
          $lines += "  public struct DEVMODE {"
          $lines += "    private const int CCHDEVICENAME = 32, CCHFORMNAME = 32;"
          $lines += "    [MarshalAs(UnmanagedType.ByValTStr, SizeConst=CCHDEVICENAME)] public string dmDeviceName;"
          $lines += "    public short dmSpecVersion, dmDriverVersion, dmSize, dmDriverExtra;"
          $lines += "    public int dmFields, dmPositionX, dmPositionY, dmDisplayOrientation, dmDisplayFixedOutput;"
          $lines += "    public short dmColor, dmDuplex, dmYResolution, dmTTOption, dmCollate;"
          $lines += "    [MarshalAs(UnmanagedType.ByValTStr, SizeConst=CCHFORMNAME)] public string dmFormName;"
          $lines += "    public short dmLogPixels; public int dmBitsPerPel, dmPelsWidth, dmPelsHeight, dmDisplayFlags, dmDisplayFrequency;"
          $lines += "    public int dmICMMethod, dmICMIntent, dmMediaType, dmDitherType, dmReserved1, dmReserved2, dmPanningWidth, dmPanningHeight;"
          $lines += "  }"
          $lines += "  [DllImport(\"user32.dll\", CharSet=CharSet.Ansi)] public static extern int ChangeDisplaySettings(ref DEVMODE devMode, int flags);"
          $lines += "  [DllImport(\"user32.dll\", CharSet=CharSet.Ansi)] public static extern bool EnumDisplaySettings(string deviceName, int modeNum, ref DEVMODE devMode);"
          $lines += "  public static int Apply(int w, int h, int bpp, int hz){"
          $lines += "    const int ENUM_CURRENT_SETTINGS = -1, CDS_UPDATEREGISTRY = 0x01, DM_PELSWIDTH=0x80000, DM_PELSHEIGHT=0x100000, DM_BITSPERPEL=0x40000;"
          $lines += "    DEVMODE dm = new DEVMODE(); dm.dmSize = (short)Marshal.SizeOf(typeof(DEVMODE));"
          $lines += "    if (!EnumDisplaySettings(null, ENUM_CURRENT_SETTINGS, ref dm)) return -999;"
          $lines += "    dm.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL;"
          $lines += "    dm.dmPelsWidth = w; dm.dmPelsHeight = h; dm.dmBitsPerPel = bpp; dm.dmDisplayFrequency = hz;"
          $lines += "    return ChangeDisplaySettings(ref dm, CDS_UPDATEREGISTRY);"
          $lines += "  }"
          $lines += "}"
          $lines += "'@"
          $lines += '$rc = [SetRes]::Apply(1920,1080,32,60)'
          $lines += 'Write-Host "ChangeDisplaySettings returned: $rc"'
          $lines += 'if ($rc -ne 0) { exit 1 }'
          Set-Content -Path $setResPs1 -Value $lines -Encoding ASCII

          # Run it under the target user's token
          $ok = $true
          try {
            Start-Process -FilePath "powershell.exe" -ArgumentList "-NoProfile -ExecutionPolicy Bypass -File `"$setResPs1`"" -Credential $cred -LoadUserProfile -WindowStyle Hidden -Wait
          } catch {
            $ok = $false
            Write-Host "Win32 API resolution apply failed: $($_.Exception.Message)"
          }

          if (-not $ok) {
            Write-Host "Applying registry fallback for headless 1920x1080..."
            function Set-HeadlessRes([int]$W=1920,[int]$H=1080){
              $gfx = "HKLM:\SYSTEM\CurrentControlSet\Control\GraphicsDrivers\Configuration"
              if (Test-Path $gfx) {
                Get-ChildItem $gfx -EA SilentlyContinue | % {
                  $k1 = Join-Path $_.PSPath "00"; $k2 = Join-Path $k1 "00"
                  try {
                    New-Item -Path $k1 -Force | Out-Null; New-Item -Path $k2 -Force | Out-Null
                    New-ItemProperty -Path $k1 -Name "PrimSurfSize.cx" -Value $W -PropertyType DWord -Force | Out-Null
                    New-ItemProperty -Path $k1 -Name "PrimSurfSize.cy" -Value $H -PropertyType DWord -Force | Out-Null
                    New-ItemProperty -Path $k1 -Name "Stride"         -Value ($W*4) -PropertyType DWord -Force | Out-Null
                    New-ItemProperty -Path $k2 -Name "ActiveSize.cx"  -Value $W -PropertyType DWord -Force | Out-Null
                    New-ItemProperty -Path $k2 -Name "ActiveSize.cy"  -Value $H -PropertyType DWord -Force | Out-Null
                  } catch {}
                }
              }
            }
            Set-HeadlessRes 1920 1080
          }

          # 100% DPI
          try {
            $sid = (Get-LocalUser -Name $TargetUser).Sid.Value
            $profilePath = (Get-CimInstance Win32_UserProfile -EA SilentlyContinue | ? { $_.SID -eq $sid }).LocalPath
            if ($profilePath) {
              $ntuser = Join-Path $profilePath "NTUSER.DAT"
              if (Test-Path $ntuser) {
                reg load "HKU\TempHive" "$ntuser" | Out-Null
                try {
                  reg add "HKU\TempHive\Control Panel\Desktop" /v LogPixels /t REG_DWORD /d 96 /f | Out-Null
                  reg add "HKU\TempHive\Control Panel\Desktop" /v Win8DpiScaling /t REG_DWORD /d 0 /f | Out-Null
                } finally { reg unload "HKU\TempHive" | Out-Null }
              }
            }
          } catch {}

      - name: Verify and keep alive
        if: ${{ always() }}
        shell: pwsh
        run: |
          Write-Host "====================================================="
          Write-Host " Chrome Remote Desktop registered as: $env:CRD_NAME"
          Write-Host " Target user is launched (userinit + explorer) for a live desktop."
          Write-Host " Resolution requested: 1920x1080 (Win32 API; registry fallback if needed)."
          Write-Host " DPI scaling set to 100%."
          Write-Host "====================================================="

          Write-Host "`n=== CRD Service Status ==="
          Get-Service -Name chromoting -ErrorAction SilentlyContinue | Format-Table -Auto

          $log = "C:\ProgramData\Google\Chrome Remote Desktop\host.log"
          if (Test-Path $log) {
            Write-Host "`n=== Host log (tail) ==="
            Get-Content $log -Tail 120
          }

          Write-Host "`n=== Explorer owners (expect to see target user) ==="
          try {
            $procs = Get-WmiObject Win32_Process -Filter "Name='explorer.exe'"
            foreach ($p in $procs){ $null=$p.GetOwner([ref]$u,[ref]$d); if ($u) { Write-Host "Explorer owned by: $d\$u" } }
          } catch {}

          Start-Sleep -Seconds (60 * [int]$env:TTL_MIN)
